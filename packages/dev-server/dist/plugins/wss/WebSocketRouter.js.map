{"version":3,"file":"WebSocketRouter.js","names":["WebSocketRouter","servers","constructor","fastify","server","on","request","socket","head","pathname","URL","url","matched","shouldUpgrade","upgrade","log","debug","msg","destroy","registerServer","push"],"sources":["../../../src/plugins/wss/WebSocketRouter.ts"],"sourcesContent":["import type { IncomingMessage } from 'node:http';\nimport type { Socket } from 'node:net';\nimport type { FastifyInstance } from 'fastify';\nimport { WebSocketServerInterface } from './types';\n\n/**\n * Class for creating a WebSocket router to forward connections to the\n * respective {@link WebSocketServer} as long as the connection is accepted for the upgrade by the\n * server.\n *\n * If the connection is not accepted by any `WebSocketServer`, it will be destroyed to avoid\n * creating handling connections and potentially throwing `ECONNRESET` errors.\n *\n * @category Development server\n */\nexport class WebSocketRouter {\n  /** The list of all register WebSocket servers. */\n  protected servers: WebSocketServerInterface[] = [];\n\n  /**\n   * Create new instance of `WebSocketRouter` and attach it to the given Fastify instance.\n   * Any logging information, will be passed through standard `fastify.log` API.\n   *\n   * @param fastify Fastify instance to attach the WebSocket router to.\n   */\n  constructor(private fastify: FastifyInstance) {\n    this.fastify.server.on(\n      'upgrade',\n      (request: IncomingMessage, socket: Socket, head: Buffer) => {\n        const { pathname } = new URL(request.url || '', 'http://localhost');\n        let matched = false;\n        for (const server of this.servers) {\n          if (server.shouldUpgrade(pathname)) {\n            matched = true;\n            server.upgrade(request, socket, head);\n            break;\n          }\n        }\n\n        if (!matched) {\n          this.fastify.log.debug({\n            msg: 'Destroying socket connection as no server was matched',\n            pathname,\n          });\n          socket.destroy();\n        }\n      }\n    );\n  }\n\n  /**\n   * Register a new {@link WebSocketServer}. New connection will now\n   * check if the given server will accept them and forward them.\n   *\n   * @param server WebSocket server to register.\n   * @returns The same instance of the WebSocket server after it's been registered.\n   */\n  registerServer<T extends WebSocketServerInterface>(server: T): T {\n    this.servers.push(server);\n    return server;\n  }\n}\n"],"mappings":"AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,eAAe,CAAC;EAC3B;EACUC,OAAO,GAA+B,EAAE;;EAElD;AACF;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAASC,OAAwB,EAAE;IAAA,KAA1BA,OAAwB,GAAxBA,OAAwB;IAC1C,IAAI,CAACA,OAAO,CAACC,MAAM,CAACC,EAAE,CACpB,SAAS,EACT,CAACC,OAAwB,EAAEC,MAAc,EAAEC,IAAY,KAAK;MAC1D,MAAM;QAAEC;MAAS,CAAC,GAAG,IAAIC,GAAG,CAACJ,OAAO,CAACK,GAAG,IAAI,EAAE,EAAE,kBAAkB,CAAC;MACnE,IAAIC,OAAO,GAAG,KAAK;MACnB,KAAK,MAAMR,MAAM,IAAI,IAAI,CAACH,OAAO,EAAE;QACjC,IAAIG,MAAM,CAACS,aAAa,CAACJ,QAAQ,CAAC,EAAE;UAClCG,OAAO,GAAG,IAAI;UACdR,MAAM,CAACU,OAAO,CAACR,OAAO,EAAEC,MAAM,EAAEC,IAAI,CAAC;UACrC;QACF;MACF;MAEA,IAAI,CAACI,OAAO,EAAE;QACZ,IAAI,CAACT,OAAO,CAACY,GAAG,CAACC,KAAK,CAAC;UACrBC,GAAG,EAAE,uDAAuD;UAC5DR;QACF,CAAC,CAAC;QACFF,MAAM,CAACW,OAAO,CAAC,CAAC;MAClB;IACF,CACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,cAAcA,CAAqCf,MAAS,EAAK;IAC/D,IAAI,CAACH,OAAO,CAACmB,IAAI,CAAChB,MAAM,CAAC;IACzB,OAAOA,MAAM;EACf;AACF","ignoreList":[]}