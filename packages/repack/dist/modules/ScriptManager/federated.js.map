{"version":3,"file":"federated.js","names":["ScriptManager","Federated","_Federated","createURLResolver","config","resolvers","key","containers","scriptId","caller","url","replace","chunks","includes","webpackContext","u","undefined","resolver","importModule","containerName","module","scope","__webpack_share_scopes__","__isInitialized","__webpack_init_sharing__","self","shared","loadScript","container","init","factory","get","exports"],"sources":["../../../src/modules/ScriptManager/federated.ts"],"sourcesContent":["import { ScriptManager } from './ScriptManager';\nimport type { WebpackContext } from './types';\n\n/**\n * Namespace for runtime utilities for Module Federation.\n */\nexport namespace Federated {\n  /**\n   * Resolves URL to a container or a chunk when using Module Federation,\n   * based on given `scriptId` and `caller`.\n   */\n  export type URLResolver = (\n    scriptId: string,\n    caller?: string\n  ) => string | ((webpackContext: WebpackContext) => string) | undefined;\n\n  /**\n   * Configuration options for {@link createURLResolver} for Module Federation.\n   * Allows to configure how created {@link URLResolver} will behave.\n   */\n  export interface URLResolverConfig {\n    /**\n     * A Module Federation container names to URL templates mapping.\n     *\n     * The key in the object is a container name and the value is a template\n     * that will be used to resolve a URL.\n     *\n     * Accepted template params:\n     * - `[name]` - Container name\n     * - `[ext]` - Container extension, eg: `.container.bundle`\n     *\n     * You can omit `[ext]`, if you're using custom extension, in which case, you should\n     * provide extension explicitly. When using custom extension, it's recommended to\n     * provide a URL template for chunks as well using `chunks` property.\n     *\n     * @example\n     * ```ts\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name][ext]'\n     *   }\n     * }\n     * ```\n     */\n    containers: Record<string, string>;\n\n    /**\n     * An optional Module Federation container names to URL templates mapping.\n     *\n     * The key in the object is a container names and the value is a template\n     * that will be used to resolve a __chunk__ URL for that container.\n     *\n     * Specifying this property is useful if:\n     * - containers have custom extension (different from `.container.bundle`)\n     * - chunks have custom extensions (different from `.chunk.bundle`)\n     * - chunks have different URL that containers\n     *\n     * When this property is left unspecified, the template URLs are inferred from\n     * `containers` property. The following:\n     * ```\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name][ext]\n     *     app2: 'http://localhost:9000/[name].js\n     *   },\n     * }\n     * ```\n     * is equivalent to:\n     * ```ts\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name][ext]',\n     *     app2: 'http://localhost:9000/[name].js',\n     *   },\n     *   chunks: {\n     *     app1: 'http://localhost:9000/[name][ext]',\n     *     app2: 'http://localhost:9000/[name].js',\n     *   },\n     * }\n     * ```\n     *\n     * Accepted template params:\n     * - `[name]` - Container name\n     * - `[ext]` - Chunk extension, eg: `.chunk.bundle`\n     *\n     * @example\n     * ```ts\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name].container.js',\n     *   },\n     *   chunks: {\n     *     app1: 'http://localhost:9000/chunks/[name][ext]',\n     *   }\n     * }\n     * ```\n     */\n    chunks?: Record<string, string>;\n  }\n\n  /**\n   * Creates URL resolver for Module Federation from provided config.\n   *\n   * @example\n   * ```ts\n   * import { ScriptManager, Script, Federated } from '@callstack/repack/client';\n   *\n   * const resolveURL = Federated.createURLResolver({\n   *   containers: {\n   *     app1: 'http://localhost:9001/[name][ext]',\n   *     app2: 'http://localhost:9002/[name].container.js',\n   *   },\n   *   chunks: {\n   *     app2: 'http://localhost:9002/chunks/[name][ext]',\n   *   },\n   * });\n   *\n   * ScriptManager.shared.addResolver(async (scriptId, caller) => {\n   *   let url;\n   *   if (caller === 'main') {\n   *     url = __DEV__\n   *       ? Script.getDevServerURL(scriptId)\n   *       : Script.getRemoteURL(`http://localhost:9000/${scriptId}`);\n   *   } else {\n   *     url = resolveURL(scriptId, caller);\n   *   }\n   *\n   *   if (!url) {\n   *     return undefined;\n   *   }\n   *\n   *   return {\n   *     url,\n   *     query: {\n   *       platform: Platform.OS,\n   *     },\n   *   };\n   * });\n   * ```\n   *\n   * `createURLResolver` is a abstraction over {@link Script.getRemoteURL},\n   * for example:\n   * ```ts\n   * import { ScriptManager, Federated } from '@callstack/repack/client';\n   *\n   * ScriptManager.shared.addResolver((scriptId, caller) => {\n   *   const resolveURL = Federated.createURLResolver({\n   *     containers: {\n   *       app1: 'http://localhost:9000/[name][ext]',\n   *     },\n   *   });\n   *\n   *   return {\n   *     url: resolveURL(scriptId, caller);\n   *   };\n   * });\n   * ```\n   * is equivalent to:\n   * ```ts\n   * import { ScriptManager, Script } from '@callstack/repack/client';\n   *\n   * ScriptManager.shared.addResolver(async (scriptId, caller) => {\n   *   if (scriptId === 'app1') {\n   *     return {\n   *       url: 'http://localhost:9000/app1.container.bundle',\n   *     };\n   *   }\n   *\n   *   if (caller === 'app1') {\n   *     return {\n   *       url: Script.getRemoteURL(`http://localhost:9000/${scriptId}`),\n   *     };\n   *   }\n   * });\n   * ```\n   *\n   * @param config Configuration for the resolver.\n   * @returns A resolver function which will try to resolve URL based on given `scriptId` and `caller`.\n   */\n  export function createURLResolver(\n    config: Federated.URLResolverConfig\n  ): Federated.URLResolver {\n    const resolvers: Record<string, Federated.URLResolver> = {};\n\n    for (const key in config.containers) {\n      resolvers[key] = (scriptId: string, caller?: string) => {\n        if (scriptId === key) {\n          const url = config.containers[key]\n            .replace(/\\[name\\]/g, scriptId)\n            .replace(/\\[ext\\]/g, '.container.bundle');\n          return url;\n        }\n\n        if (caller === key) {\n          const url = (config.chunks?.[key] ?? config.containers[key]).replace(\n            /\\[name\\]/g,\n            scriptId\n          );\n\n          if (url.includes('[ext]')) {\n            return (webpackContext: WebpackContext) =>\n              webpackContext.u(url.replace(/\\[ext\\]/g, ''));\n          }\n\n          return url;\n        }\n\n        return undefined;\n      };\n    }\n\n    return (scriptId, caller) => {\n      const resolver =\n        (caller ? resolvers[caller] : undefined) ?? resolvers[scriptId];\n\n      return resolver(scriptId, caller);\n    };\n  }\n\n  declare function __webpack_init_sharing__(scope: string): Promise<void>;\n  declare var __webpack_share_scopes__: Record<string, any>;\n  declare var self: Record<string, any>;\n\n  /**\n   * Dynamically imports module from a Module Federation container. Similar to `import('file')`, but\n   * specific to Module Federation. Calling `importModule` will create an async boundary.\n   *\n   * Container will be evaluated only once. If you use `importModule` for the same container twice,\n   * the container will be loaded and evaluated only on the first import.\n   *\n   * Under the hood, `importModule` will call `ScriptManager.shared.loadScript(containerName)`.\n   * This means, a resolver must be added with `ScriptManager.shared.addResolver(...)` beforehand and provided proper\n   * resolution logic to resolve URL based on the `containerName`.\n   *\n   * @param containerName Name of the container - should be the same name provided to\n   * `webpack.container.ModuleFederationPlugin` in `library.name`.\n   * @param module Full name with extension of the module to import from the container - only modules\n   * exposed in `exposes` in `webpack.container.ModuleFederationPlugin` can be used.\n   * @param scope Optional, scope for sharing modules between containers. Defaults to `'default'`.\n   * @returns Exports of given `module` from given container.\n   *\n   * @example\n   * ```ts\n   * import * as React from 'react';\n   * import { Federated } from '@callstack/repack/client';\n   *\n   * const Button = React.lazy(() => Federated.importModule('my-components', './Button.js'));\n   *\n   * const myUtil = await Federated.importModule('my-lib', './myUtil.js');\n   * ```\n   */\n  export async function importModule<Exports = any>(\n    containerName: string,\n    module: string,\n    scope: string = 'default'\n  ): Promise<Exports> {\n    if (!__webpack_share_scopes__[scope]?.__isInitialized) {\n      // Initializes the share scope.\n      // This fills it with known provided modules from this build and all remotes.\n      await __webpack_init_sharing__(scope);\n      __webpack_share_scopes__[scope].__isInitialized = true;\n    }\n\n    // console.log('importModule_79797979', containerName);\n\n    // Do not use `const container = self[containerName];` here. Once container is loaded\n    // `container` reference is not updated, so `container.__isInitialized`\n    // will crash the application, because of reading property from `undefined`.\n    if (!self[containerName]) {\n      // Download and execute container\n      await ScriptManager.shared.loadScript(containerName);\n    }\n\n    const container = self[containerName];\n\n    if (!container.__isInitialized) {\n      container.__isInitialized = true;\n      // Initialize the container, it may provide shared modules\n      await container.init(__webpack_share_scopes__[scope]);\n    }\n\n    const factory = await container.get(module);\n    const exports = factory();\n    return exports;\n  }\n}\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,iBAAiB;AAG/C;AACA;AACA;AAFA,WAGiBC,SAAS;AAAA,WAAAC,UAAA;EACxB;AACF;AACA;AACA;;EAME;AACF;AACA;AACA;;EAiFE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACS,SAASC,iBAAiBA,CAC/BC,MAAmC,EACZ;IACvB,MAAMC,SAAgD,GAAG,CAAC,CAAC;IAE3D,KAAK,MAAMC,GAAG,IAAIF,MAAM,CAACG,UAAU,EAAE;MACnCF,SAAS,CAACC,GAAG,CAAC,GAAG,CAACE,QAAgB,EAAEC,MAAe,KAAK;QACtD,IAAID,QAAQ,KAAKF,GAAG,EAAE;UACpB,MAAMI,GAAG,GAAGN,MAAM,CAACG,UAAU,CAACD,GAAG,CAAC,CAC/BK,OAAO,CAAC,WAAW,EAAEH,QAAQ,CAAC,CAC9BG,OAAO,CAAC,UAAU,EAAE,mBAAmB,CAAC;UAC3C,OAAOD,GAAG;QACZ;QAEA,IAAID,MAAM,KAAKH,GAAG,EAAE;UAClB,MAAMI,GAAG,GAAG,CAACN,MAAM,CAACQ,MAAM,GAAGN,GAAG,CAAC,IAAIF,MAAM,CAACG,UAAU,CAACD,GAAG,CAAC,EAAEK,OAAO,CAClE,WAAW,EACXH,QACF,CAAC;UAED,IAAIE,GAAG,CAACG,QAAQ,CAAC,OAAO,CAAC,EAAE;YACzB,OAAQC,cAA8B,IACpCA,cAAc,CAACC,CAAC,CAACL,GAAG,CAACC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;UACjD;UAEA,OAAOD,GAAG;QACZ;QAEA,OAAOM,SAAS;MAClB,CAAC;IACH;IAEA,OAAO,CAACR,QAAQ,EAAEC,MAAM,KAAK;MAC3B,MAAMQ,QAAQ,GACZ,CAACR,MAAM,GAAGJ,SAAS,CAACI,MAAM,CAAC,GAAGO,SAAS,KAAKX,SAAS,CAACG,QAAQ,CAAC;MAEjE,OAAOS,QAAQ,CAACT,QAAQ,EAAEC,MAAM,CAAC;IACnC,CAAC;EACH;EAACP,UAAA,CAAAC,iBAAA,GAAAA,iBAAA;EAMD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACS,eAAee,YAAYA,CAChCC,aAAqB,EACrBC,MAAc,EACdC,KAAa,GAAG,SAAS,EACP;IAClB,IAAI,CAACC,wBAAwB,CAACD,KAAK,CAAC,EAAEE,eAAe,EAAE;MACrD;MACA;MACA,MAAMC,wBAAwB,CAACH,KAAK,CAAC;MACrCC,wBAAwB,CAACD,KAAK,CAAC,CAACE,eAAe,GAAG,IAAI;IACxD;;IAEA;;IAEA;IACA;IACA;IACA,IAAI,CAACE,IAAI,CAACN,aAAa,CAAC,EAAE;MACxB;MACA,MAAMnB,aAAa,CAAC0B,MAAM,CAACC,UAAU,CAACR,aAAa,CAAC;IACtD;IAEA,MAAMS,SAAS,GAAGH,IAAI,CAACN,aAAa,CAAC;IAErC,IAAI,CAACS,SAAS,CAACL,eAAe,EAAE;MAC9BK,SAAS,CAACL,eAAe,GAAG,IAAI;MAChC;MACA,MAAMK,SAAS,CAACC,IAAI,CAACP,wBAAwB,CAACD,KAAK,CAAC,CAAC;IACvD;IAEA,MAAMS,OAAO,GAAG,MAAMF,SAAS,CAACG,GAAG,CAACX,MAAM,CAAC;IAC3C,MAAMY,OAAO,GAAGF,OAAO,CAAC,CAAC;IACzB,OAAOE,OAAO;EAChB;EAAC9B,UAAA,CAAAgB,YAAA,GAAAA,YAAA;AAAA,GAtRcjB,SAAS,KAATA,SAAS","ignoreList":[]}