{"version":3,"file":"AssetsCopyProcessor.js","names":["_path","_interopRequireDefault","require","_fsExtra","e","__esModule","default","AssetsCopyProcessor","queue","constructor","config","filesystem","fs","copyAsset","from","to","logger","debug","ensureDir","path","dirname","copyFile","enqueueChunk","chunk","isEntry","sourceMapFile","outputPath","bundleOutput","sourcemapOutput","bundleOutputDir","assetsDest","platform","sourcemapOutputDir","chunkFile","files","bundleDestination","join","sourceMapDestination","shouldOverrideMappingInfo","chunkSource","push","bundleContent","readFile","writeFile","replace","basename","sourceMapSource","sourceMapContent","mediaAssets","auxiliaryFiles","filter","file","test","map","asset","manifest","manifestSource","manifestDestination","manifestContent","execute","work","exports"],"sources":["../../../../src/webpack/plugins/utils/AssetsCopyProcessor.ts"],"sourcesContent":["import path from 'path';\nimport fs from 'fs-extra';\nimport webpack from 'webpack';\nimport { WebpackLogger } from '../../../types';\n\nexport class AssetsCopyProcessor {\n  queue: Array<() => Promise<void>> = [];\n\n  constructor(\n    public readonly config: {\n      platform: string;\n      outputPath: string;\n      bundleOutput: string;\n      bundleOutputDir: string;\n      sourcemapOutput: string;\n      assetsDest: string;\n      logger: WebpackLogger;\n    },\n    private filesystem: Pick<\n      typeof fs,\n      'ensureDir' | 'copyFile' | 'readFile' | 'writeFile'\n    > = fs\n  ) {}\n\n  private async copyAsset(from: string, to: string) {\n    this.config.logger.debug('Copying asset:', from, 'to:', to);\n    await this.filesystem.ensureDir(path.dirname(to));\n    await this.filesystem.copyFile(from, to);\n  }\n\n  enqueueChunk(\n    chunk: webpack.StatsChunk,\n    { isEntry, sourceMapFile }: { isEntry: boolean; sourceMapFile?: string }\n  ) {\n    const {\n      outputPath,\n      bundleOutput,\n      sourcemapOutput,\n      bundleOutputDir,\n      assetsDest,\n      platform,\n    } = this.config;\n    const sourcemapOutputDir = sourcemapOutput\n      ? path.dirname(sourcemapOutput)\n      : bundleOutputDir;\n\n    // Chunk bundle e.g: `index.bundle`, `src_App_js.chunk.bundle`\n    // There might be more than 1 file associated with the chunk -\n    // this happens e.g. on web when importing CSS files into JS.\n    // TBD whether this can ever occur in React Native.\n    const chunkFile = chunk.files?.[0];\n\n    // Sometimes there are no files associated with the chunk and the OutputPlugin fails\n    // Skipping such chunks is a temporary workaround resulting in proper behaviour\n    // This can happen when Module Federation is used and some chunks are not emitted\n    // and are only used as temporary during compilation.\n    if (!chunkFile) {\n      return;\n    }\n\n    // Target file path where to save the bundle.\n    const bundleDestination = isEntry\n      ? bundleOutput\n      : path.join(platform === 'ios' ? assetsDest : bundleOutputDir, chunkFile);\n\n    // Target file path where to save the source map file.\n    const sourceMapDestination = isEntry\n      ? sourcemapOutput\n      : path.join(\n          platform === 'ios' ? assetsDest : sourcemapOutputDir,\n          sourceMapFile ?? ''\n        );\n\n    // Entry chunks (main/index bundle) need to be processed differently to\n    // adjust file name and the content of source mapping info to match values provided by:\n    // - `--bundle-output` -> `bundleOutput`\n    // - `--sourcemap-output` -> `sourcemapOutput`\n    const shouldOverrideMappingInfo = isEntry && sourceMapFile;\n\n    // Absolute path to chunk bundle file saved in `output.path`\n    const chunkSource = path.join(outputPath, chunkFile);\n\n    // If chunk is an entry chunk, meaning it's a main/index bundle,\n    // save it based on `bundleDestination` and overwrite `sourceMappingURL`\n    // to point to correct file name (e.g: `index.bundle.map` -> `main.jsbundle.map`).\n    // Otherwise, simply copy the file to it's target `bundleDestination`.\n    if (shouldOverrideMappingInfo) {\n      this.queue.push(async () => {\n        const bundleContent = await this.filesystem.readFile(\n          chunkSource,\n          'utf-8'\n        );\n        await this.filesystem.ensureDir(path.dirname(bundleDestination));\n        await this.filesystem.writeFile(\n          bundleDestination,\n          bundleContent.replace(\n            /\\/\\/# sourceMappingURL=.*$/,\n            `//# sourceMappingURL=${path.basename(sourceMapDestination)}`\n          )\n        );\n      });\n    } else {\n      this.queue.push(() => this.copyAsset(chunkSource, bundleDestination));\n    }\n\n    if (sourceMapFile) {\n      const sourceMapSource = path.join(outputPath, sourceMapFile);\n\n      // If chunk is an entry chunk, meaning it's a main/index bundle,\n      // save the source map file for it based on `sourceMapDestination` and values inside it,\n      // to point to a correct bundle file name (e.g: `index.bundle` -> `main.jsbundle`).\n      // Otherwise, simply copy the file to it's target `sourceMapDestination`.\n      if (isEntry) {\n        this.queue.push(async () => {\n          const sourceMapContent = await this.filesystem.readFile(\n            sourceMapSource,\n            'utf-8'\n          );\n          await this.filesystem.ensureDir(path.dirname(sourceMapDestination));\n          await this.filesystem.writeFile(\n            sourceMapDestination,\n            sourceMapContent.replace(\n              chunkFile,\n              path.basename(bundleDestination)\n            )\n          );\n        });\n      } else {\n        this.queue.push(() =>\n          this.copyAsset(sourceMapSource, sourceMapDestination)\n        );\n      }\n    }\n\n    // Copy regular assets\n    const mediaAssets = [...chunk.auxiliaryFiles!]\n      .filter((file) => !/\\.(map|bundle\\.json)$/.test(file))\n      .filter((file) => !/^remote-assets/.test(file));\n\n    this.queue.push(\n      ...mediaAssets.map(\n        (asset) => () =>\n          this.copyAsset(\n            path.join(outputPath, asset),\n            path.join(assetsDest, asset)\n          )\n      )\n    );\n\n    // Manifest file name e.g: `index.bundle.json`, src_App_js.chunk.bundle.json`\n    const [manifest] = [...chunk.auxiliaryFiles!].filter((file) =>\n      /\\.bundle\\.json$/.test(file)\n    );\n    if (manifest) {\n      const manifestSource = path.join(outputPath, manifest);\n      const manifestDestination = path.join(\n        platform === 'ios' ? assetsDest : bundleOutputDir,\n        isEntry ? `${path.basename(bundleDestination)}.json` : manifest\n      );\n\n      // If chunk is an entry chunk, meaning it's a main bundle,\n      // adjust chunk and source map names inside the manifest (e.g: `index.bundle` -> `main.jsbundle`,\n      // `index.bundle.map` -> `main.jsbundle.map`).\n      // Otherwise, simply copy the manifest.\n      if (isEntry) {\n        this.queue.push(async () => {\n          const manifestContent = await this.filesystem.readFile(\n            manifestSource,\n            'utf-8'\n          );\n          await this.filesystem.ensureDir(path.dirname(manifestDestination));\n          await this.filesystem.writeFile(\n            manifestDestination,\n            manifestContent\n              .replace(chunkFile, path.basename(bundleDestination))\n              .replace(\n                sourceMapFile ?? /.^/,\n                path.basename(sourceMapDestination)\n              )\n          );\n        });\n      } else {\n        this.queue.push(() =>\n          this.copyAsset(manifestSource, manifestDestination)\n        );\n      }\n    }\n  }\n\n  execute() {\n    const queue = this.queue;\n    this.queue = [];\n    return queue.map((work) => work());\n  }\n}\n"],"mappings":";;;;;;AAAA,IAAAA,KAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,QAAA,GAAAF,sBAAA,CAAAC,OAAA;AAA0B,SAAAD,uBAAAG,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAInB,MAAMG,mBAAmB,CAAC;EAC/BC,KAAK,GAA+B,EAAE;EAEtCC,WAAWA,CACOC,MAQf,EACOC,UAGP,GAAGC,gBAAE,EACN;IAAA,KAbgBF,MAQf,GAReA,MAQf;IAAA,KACOC,UAGP,GAHOA,UAGP;EACA;EAEH,MAAcE,SAASA,CAACC,IAAY,EAAEC,EAAU,EAAE;IAChD,IAAI,CAACL,MAAM,CAACM,MAAM,CAACC,KAAK,CAAC,gBAAgB,EAAEH,IAAI,EAAE,KAAK,EAAEC,EAAE,CAAC;IAC3D,MAAM,IAAI,CAACJ,UAAU,CAACO,SAAS,CAACC,aAAI,CAACC,OAAO,CAACL,EAAE,CAAC,CAAC;IACjD,MAAM,IAAI,CAACJ,UAAU,CAACU,QAAQ,CAACP,IAAI,EAAEC,EAAE,CAAC;EAC1C;EAEAO,YAAYA,CACVC,KAAyB,EACzB;IAAEC,OAAO;IAAEC;EAA4D,CAAC,EACxE;IACA,MAAM;MACJC,UAAU;MACVC,YAAY;MACZC,eAAe;MACfC,eAAe;MACfC,UAAU;MACVC;IACF,CAAC,GAAG,IAAI,CAACrB,MAAM;IACf,MAAMsB,kBAAkB,GAAGJ,eAAe,GACtCT,aAAI,CAACC,OAAO,CAACQ,eAAe,CAAC,GAC7BC,eAAe;;IAEnB;IACA;IACA;IACA;IACA,MAAMI,SAAS,GAAGV,KAAK,CAACW,KAAK,GAAG,CAAC,CAAC;;IAElC;IACA;IACA;IACA;IACA,IAAI,CAACD,SAAS,EAAE;MACd;IACF;;IAEA;IACA,MAAME,iBAAiB,GAAGX,OAAO,GAC7BG,YAAY,GACZR,aAAI,CAACiB,IAAI,CAACL,QAAQ,KAAK,KAAK,GAAGD,UAAU,GAAGD,eAAe,EAAEI,SAAS,CAAC;;IAE3E;IACA,MAAMI,oBAAoB,GAAGb,OAAO,GAChCI,eAAe,GACfT,aAAI,CAACiB,IAAI,CACPL,QAAQ,KAAK,KAAK,GAAGD,UAAU,GAAGE,kBAAkB,EACpDP,aAAa,IAAI,EACnB,CAAC;;IAEL;IACA;IACA;IACA;IACA,MAAMa,yBAAyB,GAAGd,OAAO,IAAIC,aAAa;;IAE1D;IACA,MAAMc,WAAW,GAAGpB,aAAI,CAACiB,IAAI,CAACV,UAAU,EAAEO,SAAS,CAAC;;IAEpD;IACA;IACA;IACA;IACA,IAAIK,yBAAyB,EAAE;MAC7B,IAAI,CAAC9B,KAAK,CAACgC,IAAI,CAAC,YAAY;QAC1B,MAAMC,aAAa,GAAG,MAAM,IAAI,CAAC9B,UAAU,CAAC+B,QAAQ,CAClDH,WAAW,EACX,OACF,CAAC;QACD,MAAM,IAAI,CAAC5B,UAAU,CAACO,SAAS,CAACC,aAAI,CAACC,OAAO,CAACe,iBAAiB,CAAC,CAAC;QAChE,MAAM,IAAI,CAACxB,UAAU,CAACgC,SAAS,CAC7BR,iBAAiB,EACjBM,aAAa,CAACG,OAAO,CACnB,4BAA4B,EAC5B,wBAAwBzB,aAAI,CAAC0B,QAAQ,CAACR,oBAAoB,CAAC,EAC7D,CACF,CAAC;MACH,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,IAAI,CAAC7B,KAAK,CAACgC,IAAI,CAAC,MAAM,IAAI,CAAC3B,SAAS,CAAC0B,WAAW,EAAEJ,iBAAiB,CAAC,CAAC;IACvE;IAEA,IAAIV,aAAa,EAAE;MACjB,MAAMqB,eAAe,GAAG3B,aAAI,CAACiB,IAAI,CAACV,UAAU,EAAED,aAAa,CAAC;;MAE5D;MACA;MACA;MACA;MACA,IAAID,OAAO,EAAE;QACX,IAAI,CAAChB,KAAK,CAACgC,IAAI,CAAC,YAAY;UAC1B,MAAMO,gBAAgB,GAAG,MAAM,IAAI,CAACpC,UAAU,CAAC+B,QAAQ,CACrDI,eAAe,EACf,OACF,CAAC;UACD,MAAM,IAAI,CAACnC,UAAU,CAACO,SAAS,CAACC,aAAI,CAACC,OAAO,CAACiB,oBAAoB,CAAC,CAAC;UACnE,MAAM,IAAI,CAAC1B,UAAU,CAACgC,SAAS,CAC7BN,oBAAoB,EACpBU,gBAAgB,CAACH,OAAO,CACtBX,SAAS,EACTd,aAAI,CAAC0B,QAAQ,CAACV,iBAAiB,CACjC,CACF,CAAC;QACH,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,IAAI,CAAC3B,KAAK,CAACgC,IAAI,CAAC,MACd,IAAI,CAAC3B,SAAS,CAACiC,eAAe,EAAET,oBAAoB,CACtD,CAAC;MACH;IACF;;IAEA;IACA,MAAMW,WAAW,GAAG,CAAC,GAAGzB,KAAK,CAAC0B,cAAe,CAAC,CAC3CC,MAAM,CAAEC,IAAI,IAAK,CAAC,uBAAuB,CAACC,IAAI,CAACD,IAAI,CAAC,CAAC,CACrDD,MAAM,CAAEC,IAAI,IAAK,CAAC,gBAAgB,CAACC,IAAI,CAACD,IAAI,CAAC,CAAC;IAEjD,IAAI,CAAC3C,KAAK,CAACgC,IAAI,CACb,GAAGQ,WAAW,CAACK,GAAG,CACfC,KAAK,IAAK,MACT,IAAI,CAACzC,SAAS,CACZM,aAAI,CAACiB,IAAI,CAACV,UAAU,EAAE4B,KAAK,CAAC,EAC5BnC,aAAI,CAACiB,IAAI,CAACN,UAAU,EAAEwB,KAAK,CAC7B,CACJ,CACF,CAAC;;IAED;IACA,MAAM,CAACC,QAAQ,CAAC,GAAG,CAAC,GAAGhC,KAAK,CAAC0B,cAAe,CAAC,CAACC,MAAM,CAAEC,IAAI,IACxD,iBAAiB,CAACC,IAAI,CAACD,IAAI,CAC7B,CAAC;IACD,IAAII,QAAQ,EAAE;MACZ,MAAMC,cAAc,GAAGrC,aAAI,CAACiB,IAAI,CAACV,UAAU,EAAE6B,QAAQ,CAAC;MACtD,MAAME,mBAAmB,GAAGtC,aAAI,CAACiB,IAAI,CACnCL,QAAQ,KAAK,KAAK,GAAGD,UAAU,GAAGD,eAAe,EACjDL,OAAO,GAAG,GAAGL,aAAI,CAAC0B,QAAQ,CAACV,iBAAiB,CAAC,OAAO,GAAGoB,QACzD,CAAC;;MAED;MACA;MACA;MACA;MACA,IAAI/B,OAAO,EAAE;QACX,IAAI,CAAChB,KAAK,CAACgC,IAAI,CAAC,YAAY;UAC1B,MAAMkB,eAAe,GAAG,MAAM,IAAI,CAAC/C,UAAU,CAAC+B,QAAQ,CACpDc,cAAc,EACd,OACF,CAAC;UACD,MAAM,IAAI,CAAC7C,UAAU,CAACO,SAAS,CAACC,aAAI,CAACC,OAAO,CAACqC,mBAAmB,CAAC,CAAC;UAClE,MAAM,IAAI,CAAC9C,UAAU,CAACgC,SAAS,CAC7Bc,mBAAmB,EACnBC,eAAe,CACZd,OAAO,CAACX,SAAS,EAAEd,aAAI,CAAC0B,QAAQ,CAACV,iBAAiB,CAAC,CAAC,CACpDS,OAAO,CACNnB,aAAa,IAAI,IAAI,EACrBN,aAAI,CAAC0B,QAAQ,CAACR,oBAAoB,CACpC,CACJ,CAAC;QACH,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,IAAI,CAAC7B,KAAK,CAACgC,IAAI,CAAC,MACd,IAAI,CAAC3B,SAAS,CAAC2C,cAAc,EAAEC,mBAAmB,CACpD,CAAC;MACH;IACF;EACF;EAEAE,OAAOA,CAAA,EAAG;IACR,MAAMnD,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,IAAI,CAACA,KAAK,GAAG,EAAE;IACf,OAAOA,KAAK,CAAC6C,GAAG,CAAEO,IAAI,IAAKA,IAAI,CAAC,CAAC,CAAC;EACpC;AACF;AAACC,OAAA,CAAAtD,mBAAA,GAAAA,mBAAA","ignoreList":[]}